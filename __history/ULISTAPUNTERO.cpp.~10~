//---------------------------------------------------------------------------
#pragma hdrstop
#include "ULISTAPUNTERO.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)

Direccion ListaP::primero(){
	if (vacia)
		throw out_of_range("La lista está vacía");

	return PtrElementos;
}

Direccion ListaP::fin(){
	if (vacia) {
		throw out_of_range("La lista está vacía");
	} else {
		Direccion x = PtrElementos;
		Direccion ptrfin;
		while (x != nullptr){
			ptrfin = x;
			x = x->sig;
		}
	}
	return ptrfin;
}

void ListaP::inserta(Direccion p, TipoElemento elemento) {
	Direccion x = new Nodo;
	if (x == nullptr) {
		throw bad_alloc(); // Lanzar una excepción en caso de falla en la asignación de memoria
	} else {
	// Si la asignación de memoria fue exitosa, continuamos con la inserción del nodo
	x->elementos = elemento;
	x->sig = nullptr;
		if (vacia) {
			PtrElementos = x;
			longitud = 1;
		} else {
		longitud++;
			if (p == primero()) {
				x->sig = p;
				PtrElementos = x;
			} else {
				Direccion ant = anterior(p);
				ant->sig = x;
				x->sig = p;
			}
		}
	}
}

void ListaP::inserta_primero(TipoElemento elemento){
	Direccion x = new Nodo;
	if (x != nullptr) {
		x->elementos = elemento;
		x->sig = PtrElementos;
		longitud++;
		PtrElementos = x;
	}else{
		throw bad_alloc(); // Lanzar una excepción en caso de falla en la asignación de memoria
    }
}

void ListaP::inserta_ultimo(TipoElemento elemento){
	Direccion x = new Nodo;
	if (x != nullptr) {
		x->elementos = elemento;
		x->sig = nullptr;
		if (longitud != 0) {
			fin()->sig = x;
		} else {
			PtrElementos = x;
		}
		longitud++;
	} else {
		throw bad_alloc(); // Lanzar una excepción en caso de falla en la asignación de memoria
    }
}

Direccion ListaP::siguiente(Direccion p){
	if (vacia) {
		throw out_of_range("La lista está vacía");
	} else {
		if (p == fin()) {
			throw out_of_range("La dirección es incorrecta");
		}else{
			return p->sig;
		}
	}
}

Direccion ListaP::anterior(Direccion p){
	if (vacia) {
		throw out_of_range("La lista está vacía");
	} else {
		if (p == primero()) {
			throw out_of_range("La dirección es incorrecta");
		} else {
			Direccion x = PtrElementos;
			Direccion ant = nullptr;
			while (x != nullptr) {
				if (x == p)	{
					return ant;
				}
			ant = x;
			x = x->sig;
			}
        }
    }
}

TipoElemento ListaP::recupera(Direccion p){
	if (vacia) {
		throw out_of_range("La lista está vacía");
	}else{
		return p->elementos;
	}
}

void ListaP::suprime(Direccion p){
	if (longitud == 0) {
		throw out_of_range("La lista está vacía");
	} else {
		if (p == PtrElementos) {
			x = PtrElementos;
			PtrElementos = PtrElementos->sig;
			delete(x);
		} else {
			Direccion ant = anterior(p);
			ant->sig = siguiente(p);
			delete(p);
		}
	longitud--;
    }
}
